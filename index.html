// server.js — Philomenia backend (CommonJS, Node >=18)
const express = require("express");
const cors = require("cors");
const OpenAI = require("openai");
const jwt = require("jsonwebtoken");
const app = express();

const PORT = process.env.PORT || 10000;

// ====== ENV ======
const OPENAI_API_KEY = process.env.OPENAI_API_KEY;
const SERPER_API_KEY = process.env.SERPER_API_KEY || ""; // optionnel si tu n'utilises pas l’actu
const JWT_SECRET = process.env.JWT_SECRET || "change-me";
const ALLOWED_ORIGINS = [
  "https://philomania.com",
  "https://www.philomania.com",
  "https://philomeneia.com",
  "https://www.philomeneia.com"
];

// ====== INIT ======
if (!OPENAI_API_KEY) {
  console.error("❌ OPENAI_API_KEY manquant");
}
const openai = new OpenAI({ apiKey: OPENAI_API_KEY });

app.use(cors({ origin: (origin, cb) => {
  if (!origin) return cb(null, true);
  if (ALLOWED_ORIGINS.includes(origin)) return cb(null, true);
  return cb(null, true); // <- en debug, autorise tout (tu peux resserrer)
}}));
app.use(express.json({ limit: "15mb" }));

// ====== TIERS & QUOTAS ======
// quotas mensuels (tokens) et limites de réponse
const TIER = {
  free: { monthly: 10_000, maxTokens: 500 },
  mini: { monthly: 150_000, maxTokens: 2_000 },
  pro:  { monthly: 600_000, maxTokens: 8_000 }
};

// stockage en mémoire { [clientId]: { month:"YYYYMM", used:number } }
const usage = {};

function ymNow() {
  const d = new Date();
  return `${d.getUTCFullYear()}${String(d.getUTCMonth()+1).padStart(2,"0")}`;
}

// lit le “tier” déclaré + token coupon éventuel
function resolveTier(req) {
  let tier = (req.headers["x-tier"] || "free").toLowerCase();
  if (!["free","mini","pro"].includes(tier)) tier = "free";

  const auth = req.headers.authorization || "";
  if (auth.startsWith("Bearer ")) {
    try {
      const payload = jwt.verify(auth.slice(7), JWT_SECRET);
      if (payload?.tier === "pro") tier = "pro";
      if (payload?.tier === "mini") tier = "mini";
    } catch (_) {}
  }
  return tier;
}

// comptage ultra-simple des tokens (approx) : caractères/4 ~ tokens
function approxTokens(str) {
  if (!str) return 0;
  return Math.ceil(str.length / 4);
}

// met à jour le compteur du mois et vérifie le quota
function checkAndAddUsage(clientId, tier, promptText, replyText) {
  const month = ymNow();
  const key = clientId || "anonymous";
  const u = usage[key] || { month, used: 0 };
  if (u.month !== month) { u.month = month; u.used = 0; }

  const consumed = approxTokens(promptText) + approxTokens(replyText || "");
  const limit = (TIER[tier] || TIER.free).monthly;

  if (u.used + consumed > limit) {
    return { ok: false, used: u.used, limit, remaining: Math.max(0, limit - u.used) };
  }
  u.used += consumed;
  usage[key] = u;
  return { ok: true, used: u.used, limit, remaining: limit - u.used };
}

// ====== ROUTES ======
app.get("/health", (_, res) => res.json({ ok:true, time:new Date().toISOString() }));

// Quota visible par l’utilisateur (front envoie x-client-id et x-tier)
app.get("/api/quota", (req, res) => {
  const clientId = (req.headers["x-client-id"] || "").toString();
  const tier = resolveTier(req);
  const month = ymNow();
  const u = usage[clientId] || { month, used: 0 };
  const limit = (TIER[tier] || TIER.free).monthly;
  const remaining = Math.max(0, limit - u.used);
  const percent = Math.round((remaining / limit) * 100);
  res.json({ tier, month, used: u.used, limit, remaining, percent });
});

// Coupon : 1 mois gratuit PRO
const COUPON_CODE = process.env.COUPON_CODE || "PHILO1MOIS";
const COUPON_DAYS = parseInt(process.env.COUPON_DAYS || "30", 10);

app.post("/api/coupon/redeem", (req, res) => {
  try {
    const code = (req.body?.code || "").toString().trim().toUpperCase();
    if (!code || code !== COUPON_CODE.toUpperCase()) {
      return res.status(400).json({ ok:false, error:"Code invalide." });
    }
    const token = jwt.sign({ tier:"pro" }, JWT_SECRET, { expiresIn: `${COUPON_DAYS}d` });
    const exp = new Date(Date.now() + COUPON_DAYS*24*60*60*1000).toISOString();
    res.json({ ok:true, token, tier:"pro", expiresAt: exp });
  } catch (e) {
    res.status(500).json({ ok:false, error:"Erreur serveur." });
  }
});

// Actualités (Serper)
app.get("/api/news", async (req, res) => {
  try {
    const q = (req.query.q || "").toString().trim();
    if (!q) return res.status(400).json({ error:"Paramètre q requis" });
    if (!SERPER_API_KEY) return res.json({ results: [] });

    const r = await fetch("https://google.serper.dev/news", {
      method: "POST",
      headers: { "X-API-KEY": SERPER_API_KEY, "Content-Type":"application/json" },
      body: JSON.stringify({ q })
    });
    const data = await r.json();
    const items = (data.news || []).slice(0, 5).map(n => ({
      title: n.title, link: n.link, source: n.source, date: n.date
    }));
    res.json({ results: items });
  } catch (e) {
    res.status(500).json({ error:"News indisponibles" });
  }
});

// Chat (texte + image base64 optionnelle)
app.post("/api/chat", async (req, res) => {
  try {
    const clientId = (req.headers["x-client-id"] || "").toString();
    const tier = resolveTier(req);

    const message = (req.body?.message || "").toString().slice(0, 16000);
    const imageDataUrl = (req.body?.image || ""); // data:image/...;base64,...

    if (!message) return res.status(400).json({ error:"message requis" });

    // limite par réponse
    const maxTokens = (TIER[tier] || TIER.free).maxTokens;

    // multi-modal si image fournie
    let messages;
    if (imageDataUrl) {
      messages = [
        { role:"system", content:"Tu es Philomène, utile, claire et concise." },
        {
          role:"user",
          content: [
            { type:"text", text: message },
            { type:"image_url", image_url: { url: imageDataUrl } }
          ]
        }
      ];
    } else {
      messages = [
        { role:"system", content:"Tu es Philomène, utile, claire et concise." },
        { role:"user", content: message }
      ];
    }

    const completion = await openai.chat.completions.create({
      model: "gpt-4o-mini",
      max_tokens: maxTokens,
      temperature: 0.3,
      messages
    });

    const reply = completion.choices?.[0]?.message?.content || "(pas de réponse)";

    // mise à jour quota
    const q = checkAndAddUsage(clientId, tier, message, reply);
    if (!q.ok) {
      return res.status(402).json({
        error: "Quota mensuel atteint. Passe au plan supérieur ou attends le mois prochain.",
        quota: { used: q.used, limit: q.limit, remaining: q.remaining }
      });
    }

    res.json({ reply, quota: { used: q.used, limit: q.limit, remaining: q.remaining } });
  } catch (e) {
    console.error("chat error:", e);
    res.status(500).json({ error: "Erreur serveur" });
  }
});

app.listen(PORT, () => console.log(`✅ Backend sur le port ${PORT}`));
